****************************************
*              WARSHIPS                *
*         A game for Roona             *
****************************************
	ORG $2000

INIT	EQU $FB2F   AKA TEXT
HOME	EQU $FC58
PRBYTE	EQU $FDDA
COUT	EQU $FDED
CROUT	EQU $FD8E
RDKEY2	EQU $FD0C
VTAB	EQU $FC22

CH	EQU $24
CV	EQU $25
MASK	EQU $32
NORMAL	EQU %11111111
FLASHING	EQU $7F
INVERSE	EQU %00111111

LINE1	EQU $400    TOP LEFT
PTR	EQU $06

SHIPSCNT	EQU 5
SHIPSIZE	EQU 9

****************************************
	JMP Entry

ScrDirty	HEX 01
ShipCurr	HEX 00

Entry	JSR INIT
GameLup	LDA ScrDirty
	BEQ GameLup1
	JSR HOME
	JSR PrCols
	JSR DrwShps
	DEC ScrDirty
GameLup1	LDA #0
	STA CH
	STA CV
	JSR VTAB
	JSR Input
	JMP GameLup

* PrCols prints the column names.
PrCols	LDX #0
PrCols1	LDA PrColsD,X
	BEQ PrCols2
	STA LINE1,X
	INX
	JMP PrCols1
PrColsD	ASC " 12345678910"
	HEX 00
PrCols2	NOP

* PrRows prints the row names.
PrRows	LDX #0
PrRows1	LDA PrRowsD,X
	BEQ PrRows2,X
	JSR COUT
	JSR CROUT
	INX
	JMP PrRows1
PrRowsD	ASC " ABCDEFGHIJ"
	HEX 00
PrRows2	RTS

Quit	JSR HOME
	JSR Print
	ASC "Thank you for playing!"
	HEX 8D00
	JMP $3D0       RE-ENTER DOS

* MvCursAY moves the cursor to (A,Y)
MvCursAY	STA CH
	JMP MvCurso1
* MvCursor moves the cursor to (X,Y)
MvCursor	STX CH
MvCurso1	STY CV
	INC CH
	INC CV
	JSR VTAB
	RTS

* Input checks for a key press and
* calls the appropriate handler.
Input	JSR RDKEY2
	CMP #$9B
	BEQ Quit    ESC QUITS
	CMP #$88    LEFT ARROW
	BEQ Left
	CMP #$95    RIGHT ARROW
	BEQ Right
	CMP #$8A    DOWN ARROW
	BEQ InputDwn
	CMP #$8B    UP ARROW
	BEQ Up
	CMP #$89    TAB
	BEQ InputTab
	CMP #$D2    "R"
	BEQ InputR
	CMP #$B0
	BCC Input1
	CMP #$BA
	BCS Input1  "1"-"9"
	CLC
	SBC #$AF    A-"0" + 1
	STA CH
	BNE Input2
	LDA #10
	STA CH
	JMP Input2
Input1	CMP #$C1
	BCC Input2  A < "A"
	CMP #$CB
	BCS Input2  A >= "K"
	CLC
	SBC #$BF    A-"A" - 2?
	STA CV
	JSR VTAB
Input2	RTS
InputDwn JMP Down
InputTab	JMP Tab
InputR	JMP Rotate

Left	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	LDA Ships+0,X  SHIP.X
	BEQ Left1
	DEC Ships+0,X  SHIP.X
	INC ScrDirty
Left1	RTS

Right	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	INC Ships+0,X  SHIP.X
*
	LDA Ships+0,X  SHIP.X
	LDY Ships+2,X  SHIP.DIR
	BEQ Right1
* CHECK IF S.DIR=H && S.X + S.LEN < 10
	CLC
	ADC Ships+3,X  SHIP.LEN
	SEC
	SBC #1
Right1	CMP #10
	BCC Right2
	DEC Ships+0,X  HIT RIGHT EDGE
	RTS
Right2	INC ScrDirty
	RTS

Up	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	LDA Ships+1,X  SHIP.Y
	BEQ Left1
	DEC Ships+1,X  SHIP.Y
	INC ScrDirty
Up1	RTS

Down	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	INC Ships+1,X  SHIP.Y
*
	LDA Ships+1,X  SHIP.Y
	LDY Ships+2,X  SHIP.DIR
	BNE Down1
* CHECK IF S.DIR=V && S.X + S.LEN < 10
	CLC
	ADC Ships+3,X  SHIP.LEN
	SEC
	SBC #1
Down1	CMP #10
	BCC Down2
	DEC Ships+1,X  HIT BOTTOM
	RTS
Down2	INC ScrDirty
	RTS

Tab	INC ScrDirty
	INC ShipCurr
	LDA ShipCurr
	CMP #SHIPSCNT
	BNE Tab1
	LDA #0
	STA ShipCurr
Tab1	RTS

Rotate	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	LDA Ships+2,X  SHIP.DIR
	EOR #$FF
	STA Ships+2,X
	BNE Rotate2
* VERTICAL; CHECK HEIGHT
	LDA Ships+1,X  SHIP.Y
	CLC
	ADC Ships+3,X  SHIP.LEN
	CMP #10
	BCC Rotate3
	LDA #10
	SEC
	SBC Ships+3,X
	STA Ships+1,X
	JMP Rotate3
* HORIZONTAL; CHECK WIDTH
Rotate2	LDA Ships+0,X  SHIP.X
	CLC
	ADC Ships+3,X  SHIP.LEN
	CMP #10
	BCC Rotate3
	LDA #10
	SEC
	SBC Ships+3,X
	STA Ships+0,X
*
Rotate3	INC ScrDirty
	RTS

* Prints an ASCII string.
* From Wagner's "Assembly Lines" pg 125
Print	PLA
	STA PTR
	PLA
	STA PTR+1
	LDY #$01
Print1	LDA (PTR),Y
	BEQ Print2
	JSR COUT
	INY
	BNE Print1
Print2	CLC
	TYA
	ADC PTR
	STA PTR
	LDA PTR+1
	ADC #$00
	PHA
	LDA PTR
	PHA
	RTS

* ArrItem calculates the offset of an
* item in an array.
* INPUT:
*   X item number
*   Y size of each element
* OUTPUT:
*   X contains the offset
*   A contains the offset
*   Y is unchanged.
ArrItem	STY ArrItemT
	LDA #0
	CLC
ArrItem1	DEX
	CPX #$FF
	BEQ ArrItem2
	ADC ArrItemT
	JMP ArrItem1
ArrItem2	TAX
	RTS
*
ArrItemT HEX 00

* DrwShps draws all 5 ships.
DrwShps	LDA CH
	PHA
	LDA CV
	PHA
*	FOR I=[0,SHIPSCNT): DrwShip(I)
	LDX #0
	STX DrwShpsS
DrwShps1	LDY #SHIPSIZE
	JSR ArrItem
	JSR DrwShip
	INC DrwShpsS
	LDX DrwShpsS
	CPX #SHIPSCNT
	BNE DrwShps1
*	DRAW CURRENT SHIP INVERSE
	LDA #INVERSE
	STA MASK
	LDX ShipCurr
	LDY #SHIPSIZE
	JSR ArrItem
	JSR DrwShip
	LDA #NORMAL
	STA MASK
*
	PLA
	STA CV
	PLA
	STA CH
	JSR VTAB
	RTS
*
DrwShpsS	HEX 00

* DrwShip draws the X-th ship.
DrwShip	LDA Ships+0,X
	LDY Ships+1,X
	JSR MvCursAY
	LDA Ships+2,X
	STA ShipDir
	LDA Ships+3,X
	STA ShipLen
*	FOR Y=0; Y<SHIP.LEN; Y++
	LDY #0
DrwShip1	CPY ShipLen
	BCS DrwShip3
	LDA Ships+4,X
	JSR COUT
	LDA ShipDir
	BNE DrwShip2
	DEC CH
	INC CV
	JSR VTAB
DrwShip2	INX
	INY
	JMP DrwShip1
*
DrwShip3	RTS
*
DrwShipI HEX 00
ShipLen	HEX 00
ShipDir	HEX 00   0=HORIZ 1=VERT

* type Ship struct (size 9)
*   { 0:X 1:Y
*     2:HORIZ?
*     3:LEN
*     4-8:HITS }
Ships	DFB 0,0,0,5,$B5,$B5,$B5,$B5,$B5
	DFB 1,0,0,4,$B4,$B4,$B4,$B4,0
	DFB 2,0,0,3,$B3,$B3,$B3,0,0
	DFB 3,0,0,3,$C4,$C4,$C4,0,0
	DFB 4,0,1,2,$B2,$B2,0,0,0

* vim: set noexpandtab tabstop=9 sts=9 sw=9 invlist textwidth=40 colorcolumn=40 filetype=asmMerlin65816:
